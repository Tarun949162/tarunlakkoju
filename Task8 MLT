import numpy as np
import matplotlib.pyplot as plt

# Synthetic Medical Dataset (2 features for visualization: blood_pressure, cholesterol)
data = np.array([
    [130, 230],  # no condition
    [150, 250],  # has condition
    [120, 200],  # no condition
    [170, 280],  # has condition
    [110, 190],  # no condition
    [160, 260],  # has condition
    [140, 220],  # no condition
    [180, 300],  # has condition
])

labels = np.array([0, 1, 0, 1, 0, 1, 0, 1])

# Normalize data
data = (data - data.mean(axis=0)) / data.std(axis=0)

# Add bias input
X = np.hstack((np.ones((data.shape[0], 1)), data))
y = labels

n_inputs = X.shape[1]  # 3 (bias + 2 features)
weights = np.zeros(n_inputs)

learning_rate = 1
max_epochs = 1000

def perceptron_predict(x, weights):
    return 1 if np.dot(x, weights) > 0 else 0

errors_per_epoch = []

epoch = 0
while epoch < max_epochs:
    errors = 0
    weights_updated = False
    for i in range(len(X)):
        prediction = perceptron_predict(X[i], weights)
        error = y[i] - prediction
        if error != 0:
            weights += learning_rate * error * X[i]
            weights_updated = True
            errors += 1
    errors_per_epoch.append(errors)
    if not weights_updated:
        break
    epoch += 1

print(f"Training converged after {epoch} epochs.")
print("Final weights (including bias):")
print(weights)

# Plot 1: Training error vs epochs
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.plot(range(len(errors_per_epoch)), errors_per_epoch, marker='o')
plt.title('Training Errors per Epoch')
plt.xlabel('Epoch')
plt.ylabel('Number of Misclassifications')
plt.grid(True)

# Plot 2: Data points and decision boundary
plt.subplot(1, 2, 2)

# Separate classes for plotting
class0 = data[y == 0]
class1 = data[y == 1]

plt.scatter(class0[:, 0], class0[:, 1], color='red', label='No Condition (0)')
plt.scatter(class1[:, 0], class1[:, 1], color='blue', label='Has Condition (1)')

# Decision boundary: w0 + w1*x1 + w2*x2 = 0 => x2 = -(w0 + w1*x1)/w2
x_vals = np.linspace(min(data[:, 0]) - 1, max(data[:, 0]) + 1, 200)
if weights[2] != 0:
    y_vals = -(weights[0] + weights[1] * x_vals) / weights[2]
    plt.plot(x_vals, y_vals, 'k--', label='Decision Boundary')
else:
    print("Warning: Weight for feature 2 is zero, can't plot decision boundary")

plt.title('Data and Decision Boundary')
plt.xlabel('Blood Pressure (normalized)')
plt.ylabel('Cholesterol (normalized)')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()
